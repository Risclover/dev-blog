---
slug: live-chat-feature
title: Cloning Reddit's Live Chat Feature
authors:
  name: Sara Dunlop
  title: Junior Software Engineer
  url: https://github.com/Risclover
  image_url: https://avatars.githubusercontent.com/u/85785443?v=4
tags: [software engineering, Ribbit, fullstack, WebSockets]
---

# Live Chat Blog

I attended App Academy. Before graduation, students are required to submit and present a capstone project, which is a fullstack web application that is meant to showcase your newfound skills as a software engineer. My capstone project was a pixel-perfect clone of Reddit that I named 'Ribbit'.

After graduation, I continued to enhance Ribbit, and implementing a live chat feature using WebSockets was one of the exciting additions on my to-do list. Recently, I finally found myself in the position to tackle this feature and was successful, so I decided to share my experience with you. From initial reseasrch and planning to implementation, I will guide you through the steps involved in duplicating an existing feature. Please note that this blog post assumes a basic understanding of the languages and technologies used in the project, which include React, Redux, Flask, Flask-SQLAlchemy, and React-Router. However, the project also uses flask-socketio, which I will be going into detail about.

## Initial Research and Planning

Before diving into any project, it is crucial to spend time on research and planning. This stage sets the foundation for a successful implementation and ensures high-quality code. In this case, I started by thoroughly examining Reddit's live chat feature, paying attention to its functionality and user experience.

To illustrate the feature's intricacies, I created a GIF demonstrating its different aspects. Let's take a closer look and identify the key elements:

<center>

![yay](../6ek5EavVy4.gif)

</center>

Some noteworthy observations:

- The chat window consists of two main sections: the left side containing chat navigation and a "Create Chat" button, and the right side displaying the chat thread title, messages, and an input box.
- Chat navigation buttons provide relevant information such as the other user's image, username, the last message's content, the time it was sent, and the sender (either the other user's username or "You").
- Instead of displaying emoji stickers, the last message shows a picture emoji (üñºÔ∏è).
- Messages are grouped by date, with messages sent more than a day ago displaying the abbreviated date, and messages sent yesterday or today labeled as such.
- Each chat thread begins with an area containing the other user's image, username, karma count, and the number of days they have been on the site.

<center>

![](../Screenshot%202023-06-10%20162425.png)

</center>

- When a user sends multiple messages in a row within a minute, they are grouped together, omitting redundant information.
- Hovering over a grouped message reveals the time it was sent.
- Each message has buttons that appear on hover, allowing reactions or specific actions like deleting or reporting a message.
- Deleting a message updates its content to "[message deleted]" and changes the text color to light gray.

<center>

![](../chrome_WJ0tqnW7n0.gif)

</center>

- Clicking the "Create Chat" button opens a "New Chat" overlay where users can search and select other users to start a chat.
- The input box expands to show four lines and then allows scrolling.

<center>

![](../chrome_Q4JwmvPWTb.gif)

</center>

- When users without any existing chat threads open the chat feature, they see a "Welcome" overlay with a "Start new chat" button that leads to the "New Chat" overlay when clicked.

<center>

![](../welcome-overlay.png)

</center>

By studying these details, we gain a comprehensive understanding of the feature and can ensure a faithful recreation.

## Backend: Models and Routes

When working on a full-stack project, I prefer starting with the backend and then proceeding to the frontend. This approach minimizes the need to switch back and forth between the two and ensures smoother development. Although some backend adjustments may be necessary later, completing most of the backend work upfront allows me to focus solely on the frontend when the time comes.

### Models

To begin, let's consider the necessary database tables based on user actions:

1. Creating a new chat thread by clicking the "Create Chat" button.
2. Sending messages through the input box.
3. Clicking on a chat navigation button to open the respective thread.
4. "Deleting" a message by updating its content.

All interactions are with either the chat threads themselves or with messages, which makes it clear that we need to include two models: `ChatThread` and `ChatMessage`.

In addition, we have a many-to-many relationship between users and chat threads (chat threads can have many users, and users can have many chat threads), so we'll need an association table that we'll call `user_chat_threads`.

As a quick side note, some of the code snippets in this blog post have an import statement at the top that says `from .db import db`. To clear up any potential confusion, this is referring to the `db.py` file, which holds the following code:

```python
from flask_sqlalchemy import SQLAlchemy
import os
environment = os.getenv("FLASK_ENV")
db = SQLAlchemy()
```

Let's begin with the `user_chat_threads` table to establish the relationship between users and chat threads:

```python
from .db import db

user_chat_threads = db.Table('user_chat_threads',
  db.Model.metadata,
  db.Column('user_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),
  db.Column('chat_thread_id', db.Integer, db.ForeignKey('chat_message_threads.id'), primary_key=True),
)
```

Next, we have the `ChatThread` model to represent a chat thread between two users.

```python
from .db import db

# ...

class ChatThread(db.Model):
    __tablename__ = "chat_threads"

    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, server_default.db.func.now())
    messages = db.relationship('ChatMessage', back_populates='chat_message_thread', cascade='all, delete')
    chat_thread_users = db.relationship('User', back_populates='chat_threads', secondary=user_chat_threads, lazy='joined')
```

- `id` - Primary key for the chat thread
- `created_at` - Timestamp indicating when the chat thread was created
- `messages` - One-to-many relationship with the `ChatMessage` model to represent the messages in the thread. `cascade='all, delete'` ensures that when the chat thread is deleted, its messages get deleted, too.
- `chat_thread_users` - Many-to-many relationship with the `User` model to associate the users participating in the chat thread. Note the user of the `secondary` argument, which associates the `user_chat_threads` table.

Finally, we have the `ChatMessage` model:

```python
from .db import db

# ...

class ChatMessage(db.Model):
    __tablename__ = "chat_messages"

    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete="CASCADE"), nullable=False)
    receiver_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    content = db.Column(db.String(10000), nullable=False)
    thread_id = db.Column(db.Integer, db.ForeignKey("chat_message_threads.id"), unique=False, nullable=False)
    read = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, server_default=db.func.now())

    chat_message_thread = db.relationship('ChatMessageThread', back_populates="messages")
    sender = db.relationship("User", back_populates="user_chat_messages", primaryjoin="User.id==ChatMessage.sender_id")
    recipient = db.relationship("User", primaryjoin="User.id==ChatMessage.receiver_id")
```

- `id` - Primary key for the chat message.
- `sender_id` - The user id for user sending the message.
- `receiver_id` - The user id for the user receiving the message.
- `content` - The contents of the message.
- `thread_id` - The id of the chat thread the message belongs to.
- `read` - A boolean indicating whether or not the message has been seen, or "read", for the purposes of notifications.
- `created_at` - The timestamp of when the message was sent.
- `chat_message_thread` - One-to-many relationship with the `ChatThread` model to represent...well, the thread that the messages belong to, I guess.
- `sender` -
- `recipient` -

### Routes

With our models designed and written, we can move on to our endpoints. We can refer to the same list of actions that we referenced in the previous section to help us figure out what endpoints we need:

1. Creating a new chat thread by clicking the "Create Chat" button.
2. Sending messages through the input box.
3. Clicking on a chat navigation button to open the respective thread.
4. "Deleting" a message by updating its content.

Let's start with our import statements.

```python
from flask import Blueprint, request
from flask_login import login_required, current_user
from app.models import db, User, ChatThread, ChatMessage
```

- From `flask`:

  - `Blueprint` - Used to add views to our route using the `route` decorator
  - `request` - Contains the data that the client has sent to our app

- From `flask_login`:

  - `login_required` - Restricts views to logged-in users
  - `current_user` - Access to the logged-in user

- From `app.models`: The models that we reference within our routes (`db`, `User`, `ChatThread`, `ChatMessage`).

Following this, we need to name our route:

```python
# Import statements

# ...

chat_thread_routes = Blueprint("chat_threads", __name__)
```

Now we can use `@chat_thread_routes.route` to add our views to `chat_threads`.

Starting with our endpoints for chat threads, we need to be able to "GET" a user's threads.

```python
@chat_thread_routes.route("")
def get_user_chats():
    user = User.query.get(current_user.get_id())
    if user is not None:
        user_chats = user.chat_threads
        return { "ChatThreads": [ chat.to_dict() for chat in user_chats]}
    else:
        return { "message": "error" }
```

Here, we find the logged-in user using `current_user.get_id()`, which literally gets the id of the current user, and querying our User model with it.

Then we say that if `user` exists (`is not None`), we need to return the user's chat threads, which are held in `user.chat_threads`. The return statement turns each chat thread into a dictionary (`chat.to_dict()`) so that we may use its properties.

If `user` does not exist, we return a simple error message.

Next, it would be handy to be able to get a specific chat thread by its id, so let's write an endpoint that can do just that.

```python
# 3. Clicking on a chat navigation button to open the respective thread.
@chat_thread_routes.route("/<int:id>")
def get_user_chat(id):
    chat = ChatThread.query.get(id)
    if chat is not None:
        return chat.to_dict()
    else:
        return {"message": "Chat not found"}
```

This time, we find a specific chat thread by grabbing its id, which is stored as a parameter in the route. If a chat thread with that id exists, we return it as a dictionary, and if not, we return a "Chat not found" message.

Our final chat thread-related endpoint allows us to create chat threads using `POST`.

```python
# 1. Creating a new chat thread by clicking the "Create Chat" button.
@chat_thread_routes.route("", methods=["POST"])
@login_required
def create_thread():
    data = request.get_json()
    receiver = User.query.get(data.get("receiverId"))
    sender = User.query.get(current_user.get_id())

    thread = ChatMessageThread()
    receiver.chat_threads.append(thread)
    sender.chat_threads.append(thread)

    db.session.add(thread)
    db.session.commit()


    return { "chatThread": thread.to_dict() }
```

We are utilizing the `@login_required` decorator here, because users who aren't logged in shouldn't be able to create chat threads.

We are also utilizing the `request` object - specifically, the `get_json()` method, which parses the incoming JSON request data and returns it so we may reference it.

For example, after setting `request.get_json()` to a variable called `data`, when we write the code `data.get("receiverId")`, this is literally the receiver's id, which we set to the `receiverId` variable in the frontend before converting it to JSON.

- `receiver = User.query.get(data.get("receiverId"))` - We find the receiver by their user id and set it to the `receiver` variable
- `sender = User.query.get(current_user.get_id())` - Once again, we find the current user by using `current_user.get_id()`, and we set it to the `sender` variable.
- `thread = ChatThread()` - We create our chat thread. We don't need any information inside the parentheses for this particular model.
- `receiver.chat_threads.append(thread)` - Remember the `chat_threads` field that we gave the `User` model earlier? We append our newly-created thread to it so that the receiving user now has that thread.
- `sender.chat_threads.append(thread)` - We do the same for the sending user.
- `db.session.add(thread)` - Our new thread is added to the database...
- `db.session.commit()` - and committed.

We finish off this endpoint by returning a dictionary form of our chat thread.

We now move on to the endpoints for chat messages. Just like with chat threads, we need to be able to create a message with `POST`, but we'll also simultaneously add the message to its chat thread.

```python
# 2. Sending messages through the input box.
@chat_thread_routes.route("/<int:id>/messages", methods=["POST"])
@login_required
def create_message(id):
    data = request.get_json()

    message = ChatMessage(
        content=data.get("content"),
        sender_id=current_user.get_id(),
        receiver_id = data.get("receiver_id"),
        thread_id = id
    )

    chat_thread = ChatMessageThread.query.get(id)
    chat_thread.messages.append(message)

    db.session.add(message)
    db.session.commit()

    return message.to_dict()
```

We've already discussed what the `@login_required` decorator and the `data = request.get_json()` line do, so let's move right along.

```python
message = ChatMessage(
  content=data.get("content"),
  sender_id=current_user.get_id(),
  receiver_id = data.get("receiver_id"),
  thread_id = id
)
```

Here, we create our new message, passing along the following parameters:

- `content=data.get("content")` - Our message's content
- `sender_id=current_user.get_id()` - We set the sender's id to the current user's id, since they will always be one in the same.
- `receiver_id=data.get("receiver_id")` - We get the receiver's id from data
- `thread_id=id` - Our thread id comes directly from the route.

```python
chat_thread = ChatMessageThread.query.get(id)
chat_thread.messages.append(message)

db.session.add(message)
db.session.commit()

return message.to_dict()
```

Following that, we simply find the correct chat thread by its id, append our new message to the chat thread's `messages` property, add the message to the database, commit, and finally, return a dictionary version of our message.

We've covered most of our "actions" list, but there is one more action to do: "deleting" a message.

```python
# 4. "Deleting" a message by updating its content.
@chat_thread_routes.route("/messages/<int:id>", methods=["PUT"])
@login_required
def fake_delete_message(id):
    message = ChatMessage.query.get(id)
    setattr(message, "content", "[Message deleted]")

    db.session.commit()
    return message.to_dict()
```

Since this is just an update, we use `PUT` - and more specifically, the `setattr()` method, which is a Python function that sets the value of the specified attribute; or, in other words, changes the value of the `"content"` attribute of the `message` to `"[Message deleted]"`.

We commit this change to the database and return our message as a dictionary.

## WebSockets Backend

Our last backend task is to create the `flask-socketio` endpoints needed to turn our chat feature into a live chat feature. First, let's briefly cover what WebSockets are and why they are used for real-time communication.

WebSockets are a communication protocol that provides communication channels over a single connection. Unlike traditional HTTP requests, which are stateless and require a new request-response cycle for every communication, WebSockets allow for continuous, bidirectional communication between the client and the server, making WebSockets ideal for implementing real-time features like chat applications.

To implement WebSockets in our live chat feature, we'll be using the `flask-socketio` library, which integrates Socket.IO with Flask and provides the necessary functionality to handle real-time communication.

Let's start by adding required code to `__init__.py`:

```python
# At the top with the other import statements:
from .socket import socketio

# Following `db.init_app(app)`:
socketio.init_app(app)

# At the bottom of the file:
if __name__ == '__main__':
    socketio.run(app)
```

From the `flask-socketio` documentation:

> The `init_app()` style of initialization is also supported. To start the web server simply execute your script. Note the way the web server is started. The `socketio.run()` function encapsulates the start up of the web server and replaces the `app.run()` standard Flask development server start up.
>
> . . .
>
> The simplest deployment strategy is to start the web server by calling `socketio.run(app)`. This will look through the packages that are installed for the best available web server start the application on it. The current web server choices that are evaluated are eventlet, gevent and the Flask development server.
>
> If eventlet or gevent are available, `socketio.run(app)` starts a production-ready server using one of these frameworks. If neither of these are installed, then the Flask development web server is used, and in this case the server is not intended to be used in a production deployment.

The `socketio.init_app(app)` line initializes the SocketIO instance with our Flask app.

Next, we'll create a new file called `socket.py` in the `app/` folder (which is the root backend folder) to handle the remaining backend code needed for WebSockets.

```python
# socket.py

from flask_socketio import SocketIO, emit, join_room, leave_room
from app.models import db, User, ChatMessage
from flask_login import current_user
from flask import request

import os

# configure cors_allowed_origins
if os.environ.get('FLASK_ENV') == 'production':
    origins = [
        'http://ribbit-app.herokuapp.com',
        'https://ribbit-app.herokuapp.com'
    ]
else:
    origins = "*"

# initialize your socket instance
socketio = SocketIO(cors_allowed_origins=origins)
```

At the top of `socket.py`, we import the necessary modules and initialize the `socketio` instance with the appropriate CORS settings.

Next, we can move on to the WebSocket endpoints. We start by creating the `chat_users` variable, which is initialized as an empty list and will hold the data of users currently connected, followed by the connection and disconnection events:

```python
chat_users = []

@socketio.on("connect")
def on_connect():
    user = User.query.get(current_user.get_id()).username
    user_exists = len([user for user in chatUsers if user['username'] == user])
    if not user_exists:
        chat_user = {}
        chat_user['username'] = user
        chat_user['sid'] = request.sid
        chat_users.append(chatUser)


@socketio.on("disconnect")
def on_disconnect():
    for i in range(len(chatUsers)):
        if chat_users[i]['username'] == User.query.get(current_user.get_id()).username:
            del chat_users[i]
            break
```

In the `on_connect` event, we retrieve the username of the connected user and check if they already exist in the `chat_users` list. If not, we create a new entry for the user and add it to the list.

In the `on_disconnect` event, we remove the user from the `chat_users` list when they disconnect.

Next, let's handle the messaging functionality.

```python
# handle chat messages
@socketio.on("chat")
def handle_chat(data):
    if data['threadId']:
        room = data['threadId']
        emit("chat", data, broadcast=True, to=room)
        emit("new_message", data, broadcast=True, to=room)
```

The `handle_chat` event grabs the thread's id from the incoming JSON data, and we create a new room based on that id, making rooms and chat threads pretty much one in the same.

Following that are two `emit()` statements. Both of these statements send the incoming data to the room and broadcasts it to that room.

There are two `emit()` statements because we need one for sending a message and one for updating the chat nav button live.

Lastly, we'll implement the events to join and leave chat rooms.

And with that, we complete our backend code! Note that I haven't mentioned or shown things like registering our chat_thread_routes blueprint or adding our models to the `models/__init__.py` file. As I mentioned in the beginning, this post assumes that you've used Flask and SQLAlchemy before. If you are using this as a guide, just don't forget to handle those details.

## Redux

Before we talk about the crux of this post - the React components - let's briefly go over the Redux code.

In the redux file, `chats.js`, we have the following thunks to pair with our endpoints:

- `getUserChatThreads`
- `getChatThread`
- `createChatThread`
- `createChatMessage`
- `fakeDeleteMessage`
- `readAllMessages`

```javascript
const LOAD_CHAT_THREADS = "chat_threads/LOAD_CHAT_THREADS";
const LOAD_CHAT_THREAD = "chat_threads/LOAD_CHAT_THREAD";

const loadChatThreads = (chatThreads) => {
  return {
    type: LOAD_CHAT_THREADS,
    chatThreads,
  };
};

const loadChatThread = (chatThread) => {
  return {
    type: LOAD_CHAT_THREAD,
    chatThread,
  };
};

export const getUserChatThreads = () => async (dispatch) => {
  const response = await fetch("/api/chat_threads");

  if (response.ok) {
    const data = await response.json();
    dispatch(loadChatThreads(data));
    return data;
  }
};

export const getChatThread = (chatThreadId) => async (dispatch) => {
  const response = await fetch(`/api/chat_threads/${chatThreadId}`);
  if (response.ok) {
    const data = await response.json();
    dispatch(loadChatThread(data));
    return data;
  }
};

export const createChatThread = (receiverId) => async (dispatch) => {
  const response = await fetch("/api/chat_threads", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ receiverId: receiverId }),
  });

  if (response.ok) {
    const data = await response.json();
    dispatch(loadChatThread(data));
    return data;
  }
};

export const createChatMessage = (payload) => async (dispatch) => {
  const { content, receiverId, chatThreadId } = payload;
  const response = await fetch(`/api/chat_threads/${chatThreadId}/messages`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      content: content,
      receiver_id: receiverId,
    }),
  });

  if (response.ok) {
    const data = await response.json();
    return data;
  } else if (response.status < 500) {
    const data = await response.json();
    if (data.errors) {
      return data;
    }
  } else {
    return ["An error occurred. Please try again."];
  }
};

export const createReaction = (payload) => async (dispatch) => {
  const { emoji, userId, messageId } = payload;

  const response = await fetch(`/api/messages/${messageId}/reactions`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      emoji,
      user_id: userId,
    }),
  });

  if (response.ok) {
    const data = await response.json();
    return data;
  } else if (response.status < 500) {
    const data = await response.json();
    if (data.errors) {
      return data;
    }
  } else {
    return ["An error occurred. Please try again."];
  }
};

export const fakeDeleteMessage = (messageId) => async (dispatch) => {
  const response = await fetch(`/api/chat_threads/messages/${messageId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
  });

  if (response.ok) {
    const data = await response.json();
    return data;
  }
};

export const readAllMessages = (threadId) => async (dispatch) => {
  const response = await fetch(`/api/chat_threads/${threadId}/read`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
  });

  if (response.ok) {
    const data = await response.json();
    return data;
  }
};

const initialState = {};

export default function chatThreadReducer(state = initialState, action) {
  switch (action.type) {
    case LOAD_CHAT_THREADS:
      if (action.chatThreads && action.chatThreads.ChatThreads) {
        return action.chatThreads.ChatThreads.reduce(
          (chatThreads, chatThread) => {
            chatThreads[chatThread.id] = chatThread;
            return chatThreads;
          },
          {}
        );
      }
      return state;

    case LOAD_CHAT_THREAD:
      return { ...state, [action.chatThread.id]: action.chatThread };

    default:
      return state;
  }
}
```

## Setting Up the Frontend

We have finally made it to the meat of this feature - the React components that sit in the `src/` file on the frontend. Hooray! Give yourself a knuckle-touch.

### File Structure & Initial Setup

As it stands, our frontend is currently pretty bare, so we need to create some components. Let's go ahead and create a folder structure diagram.

```

Chat/
‚îú‚îÄ ChatLeft/
‚îÇ  ‚îú‚îÄ ChatLeft.js
‚îÇ  ‚îú‚îÄ ChatNav.js
‚îÇ  ‚îî‚îÄ ChatNavBtn.js
‚îÇ
‚îú‚îÄ ChatRight/
‚îÇ  ‚îú‚îÄ ChatRight.js
‚îÇ  ‚îú‚îÄ ChatTitleBar.js
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ ChatInput/
‚îÇ  ‚îÇ  ‚îú‚îÄ ChatInput.js
‚îÇ  ‚îÇ  ‚îî‚îÄ ChatEmojis.js
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ ChatMessages/
‚îÇ  ‚îÇ  ‚îú‚îÄ ChatMessages.js
‚îÇ  ‚îÇ  ‚îî‚îÄ ChatMessage.js
‚îÇ  ‚îÇ
‚îú‚îÄ ChatOverlays/
‚îÇ  ‚îú‚îÄ WelcomeOverlay.js
‚îÇ  ‚îú‚îÄ NewChatOverlay.js
‚îÇ  ‚îú‚îÄ InviteOverlay.js
‚îÇ  ‚îî‚îÄ DeleteMsgOverlay.js
‚îÇ
‚îú‚îÄ Chat.js
‚îî‚îÄ Chat.css
```

We start with our overall folder, `Chat` - specifically our main component, `Chat.js`.

The chat window is divided into two main parts - the left side and the right side - so we decided to structure the folders like that by creating a `ChatLeft/` folder and a `ChatRight/` folder. We also have `ChatOverlays` to hold the handful of overlays we need. Since these overlays are absolutely positioned, they aren't necessarily in the `ChatRight` group, and we can keep them in a general place instread.

Create all of these files and folders before we move on. As you create each file, take a moment to create the React function and its container div. Here, we do it for `Chat.js`, `ChatLeft.js`, and `ChatNav.js`. Do the same for the right side and the overlays.

```javascript
// Chat.js
import React from "react";
import ChatLeft from "./ChatLeft/ChatLeft";
import ChatRight from "./ChatRight/ChatRight";

const Chat = () => {
  return (
    <div className="chat-container">
      <ChatLeft />
      <ChatRight />
    </div>
  );
};

export default Chat;
```

```javascript
// ChatLeft.js
import ChatNav from "./ChatNav";

const ChatLeft = () => {
  return (
    <div className="chat-left-container">
      <ChatNav />
    </div>
  );
};

export default ChatLeft;
```

```javascript
// ChatNav.js
import ChatNavBtn from "./ChatNavBtn";

const ChatNav = () => {
  return <div className="chat-nav-container"></div>;
};

export default ChatNav;
```

Note that for `ChatNav`, we import ChatNavBtn and leave it for now. Since we'll be mapping to that component, we don't need it just yet.

Once all of the files are set up, we can move on to initial styling.

### Initial Styling

It's hard to manually test a feature if it doesn't exist physically, so we need to set up some basic styling including the chat window's layout, the general size of each component, giving the feature a background, etc.

```css
.chat-container {
  width: 632px;
  height: 506px;
  bottom: 0;
  right: 1.875rem;
  border-radius: 1rem 1rem 0 0;
  box-shadow: 0 0.125em 0.75em 0.125em rgba(20, 120, 120, 0.11);
  top: auto;
  position: fixed;
  overflow: hidden;
  background: white;
  z-index: 9999;
  border: 1px solid #edeff1;
  border-bottom: none;
  font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  display: flex;
}
```

This is all of the css we'll need for `.chat-container`, and results in this:

<center>

![](../initial-styling.png)

</center>

It also gives it the correct placement on the page, as seen here:

![](../initial-styling1.png)

:::info Regarding the font family used in `.chat-container`

```css
font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,
  "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
```

This is known as a **native font stack** or **system font stack**. It essentially uses the operating system's default system font, accounting for all of the major operating systems used today (macOS, Windows, Android, Ubuntu). Using this can help boost performance because the browser doesn't have to download any font files since it's using one it already had.

Reddit actually uses

```css
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
  "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji",
  "Segoe UI Symbol", sans-serif;
```

However, according to a [thorough write-up](https://css-tricks.com/implementing-system-fonts-booking-com%E2%80%8A-%E2%80%8Aa-lesson-learned/) published by Booking.com, using snippets starting with `-apple-system` may cause some browsers to view the leading font as a vendor prefix that will be ignored.

Chrome and Safari recently shipped "system-ui", which is a generic font family that can be used in place of `-apple-system` and `BlinkMacSystemFont`, and is the font family we're using today.
:::

Follow this by adding the following css code:

```css
.chat-left-container {
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  border-right: 1px solid #edeff1;
  max-width: 220px;
  width: 100%;
}

.chat-right-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
}

.chat-nav-container {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}

.chat-messages-container {
  overflow: hidden auto;
  height: 100%;
  width: 100%;
  flex: 1 0 0px;
}

.chat-input-container {
  padding: 8px;
  display: flex;
  align-items: center;
  position: relative;
}
```

After applying this code, our chat component looks like this:

<center>

![](./../initial-styling2.png)

</center>

As you can see, this successfully lays out our components and makes sure they're all of the correct size and placement. The component names have been left in to accurately show where our components are, but you don't necessarily need to leave them in yourself.

## Coding the Frontend: Chat Access & Doing the Overlays

It's time to start coding our frontend components. We may as well begin where the user begins: Opening the chat component.

On Reddit, there are two ways to access Chat - via a button in the top navbar, and via the 'Chat' button on user profile pages, both shown here:

<center>

<figure>

![](../chatnav-btn.png)<figcaption><em>The chat button located in the top navbar</em></figcaption>

</figure>

<figure>

![](../profile-chat-btn.png)<figcaption><em>The chat button located on a user's profile page</em></figcaption>

</figure>
</center>

Since we know that we're going to need two access points that are in two completely different components, we need to create the relevant state variables in a place that can reach both components. For Ribbit, that would be all the way back in `App.js`, in which we add this code:

```javascript
const [openChat, setOpenChat] = useState(false);
const [selectedChat, setSelectedChat] = useState(chatThreads[0]);

// ...

return (
  // ...

  {openChat && (
    <Chat
      openChat={openChat}
      setOpenChat={setOpenChat}
      setSelectedChat={setSelectedChat}
      selectedChat={selectedChat}
    />
  )}

  // ...
)
```

Now, when `openChat` is `true`, our `Chat` component will appear.

Also included is the `selectedChat` state variable, which represents the chat thread currently active in the chat window.

:::info Not shown:

Not shown in the above code are the `NavBar` and `UserProfile` components, to which our state variables are also passed.

:::

### NavBar Button

First, let's check out the functionality of the navbar button. When clicked, the chat window opens either to the most recently updated chat thread, or, if no chat threads exist, to the "Welcome" overlay:

<center>

![](../welcome-overlay.png)

</center>

This is something to keep in mind when we work on the button's functionality.

Moving on to creating the actual button, let's take another look at the screenshot from earlier:

<center>

![](../chatnav-btn.png)

</center>

Reddit has given the button an icon that looks like a chat bubble with 3 dots inside. Let's try to find that icon or something similar.

:::note Finding Icons
When it comes to finding an icon, I personally don't like to deviate from using the [react-icons](https://react-icons.github.io/react-icons/) library, because doing so usually requires downloading the image instead of simply importing it from the library.

If I really can't find anything close on react-icons, I'll typically try either [The Noun Project](https://thenounproject.com) or [flaticon](https://www.flaticon.com/).
:::

In this case, I used [react-icons](https://react-icons.github.io/react-icons) library to find the icon I needed (re: chat bubble with 3 dots inside).

In the `NavBar` component, the icon is placed into a `button` element, and we add a click event that points to a function we'll call `handleOpenChat`.

```javascript
import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { BsChatDots } from "react-icons/bs";

// Other import statements go here

const NavBar = ({ setOpenChat, OpenChat, setSelectedChat }) => {
  const dispatch = useDispatch();
  const chatThreads = useSelector((state) => state.chatThreads);
  const [showTooltip, setShowTooltip] = useState(false);

  // Sorts the threads in the chatThreads array so that the chat thread with the latest message sent is set as the most recent one, aka the thread at the top of the chat navigation.
  const sortedThreads = Object.values(chatThreads).sort((a, b) => {
    const aMessages = a.messages;
    const bMessages = b.messages;
    if (aMessages && bMessages) {
      const aLastMessage = aMessages[aMessages?.length - 1];
      const bLastMessage = bMessages[bMessages?.length - 1];

      if (aMessages?.length === 0 && bMessages?.length === 0) {
        return a.createdAt.localeCompare(b.createdAt);
      }

      if (aMessages?.length === 0) {
        return 1;
      }

      if (bMessages?.length === 0) {
        return -1;
      }

      return (
        new Date(bLastMessage.createdAt) - new Date(aLastMessage.createdAt)
      );
    }
  });

  const handleOpenChat = (e) => {
    e.preventDefault();
    setSelectedChat(sortedThreads[0]);
    setOpenChat(!openChat);
  };

  // ...

  return (
    // ...

    <button
      className="navbar-button"
      onMouseEnter={() => setTimeout(() => setShowTooltip(true), 500)}
      onMouseLeave={() => setShowTooltip(false)}
      onClick={handleOpenChat}
    >
      <BsChatDots />
      {showTooltip && <span className="navbtn-tooltiptext">Chat</span>}
    </button>

    // ...
  );
};
```

Since this is fairly long, let's break it up and talk about each part individually.

```javascript
import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { BsChatDots } from "react-icons/bs";
```

These are our import statements. We import the `useState` hook from `react`, and `useDispatch` and `useSelector` from react-redux. We also grab the icon needed for the chat button from `react-icons`.

```javascript
const NavBar = ({ setOpenChat, openChat, setSelectedChat }) => {
  const dispatch = useDispatch();
  const chatThreads = useSelector((state) => state.chatThreads);
  const [showTooltip, setShowTooltip] = useState(false);

  // ...
};
```

Next, we create the `NavBar` component, making sure to import the `setOpenChat`, `openChat`, and `setSelectedChat` props. We use the `useDispatch()` hook (giving it the `dispatch` variable), followed by setting the variable `chatThreads` to the chat threads in the redux state, which we grabbed via `useSelector`.

We also create the `showTooltip` state variable, though this is optional.

```javascript
// Sorts the threads in the chatThreads array so that the chat thread with the latest message sent is set as the most recent one, aka the thread at the top of the chat navigation.
const sortedThreads = Object.values(chatThreads).sort((a, b) => {
  const aMessages = a.messages;
  const bMessages = b.messages;
  if (aMessages && bMessages) {
    const aLastMessage = aMessages[aMessages?.length - 1];
    const bLastMessage = bMessages[bMessages?.length - 1];

    if (aMessages?.length === 0 && bMessages?.length === 0) {
      return a.createdAt.localeCompare(b.createdAt);
    }

    if (aMessages?.length === 0) {
      return 1;
    }

    if (bMessages?.length === 0) {
      return -1;
    }

    return new Date(bLastMessage.createdAt) - new Date(aLastMessage.createdAt);
  }
});
```

Here, we have a long code block for `sortedThreads`, which is the array of chat threads, but sorted by when the latest message was sent.

As far as the `handleOpenChat` function, we keep it fairly simple.

```javascript
const handleOpenChat = (e) => {
  e.preventDefault();
  setSelectedChat(sortedThreads[0]);
  setOpenChat(!openChat);
};
```

With our chat threads sorted by latest message sent, we set the selected chat to the first item in the list, which will be the top thread in the chat navigation. We also `setOpenChat` to whatever the opposite of `openChat`'s current state is, so that clicking the button both opens and closes the chat window.

Finally, we have our actual button in the JSX code.

```javascript
<button
  className="navbar-button"
  onMouseEnter={() => setTimeout(() => setShowTooltip(true), 500)}
  onMouseLeave={() => setShowTooltip(false)}
  onClick={handleOpenChat}
>
  <BsChatDots />
  {showTooltip && <span className="navbtn-tooltiptext">Chat</span>}
</button>
```

Here, we set the `onClick` event to our `handleOpenChat` function, and set our chosen icon as the button's contents.

:::note The button's tooltip

Included in the above code is the code that handles the button's tooltip, which can be seen in the screenshot of the navbar's chat button.

1. Hanging out near the top of the inside of the `NavBar` component is this state variable:

   ```javascript
   const [showTooltip, setShowTooltip] = useState(false);
   ```

2. We give our "button" (a simple `div` element instead of an actual `button` element) three events, two of which are `onMouseEnter` and `onMouseLeave`:

   ```javascript
   onMouseEnter={() => setTimeout(() => setShowTooltip(true), 500)}
   onMouseLeave={() => setShowTooltip(false)}
   ```

   When the mouse enters the chat button, we set a timeout that shows the tooltip after a half second (500 milliseconds). When the mouse leaves the chat button, we close the tooltip.

3. Inside of the button is the tooltip itself:

   ```javascript
   {
     showTooltip && <span className="navbtn-tooltiptext">Chat</span>;
   }
   ```

   So, when `showTooltip` is `true`, the tooltip, which says "Chat", appears.

:::
